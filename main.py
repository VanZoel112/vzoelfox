#!/usr/bin/env python3
"""
VZOEL ASSISTANT - ENHANCED MAIN FILE
Complete Telegram Userbot with improved gcast and new features
Author: Vzoel Fox's (LTPN)
Version: v2.1 Enhanced Edition
File: main.py
"""

import asyncio
import logging
import time
import random
import re
import os
import sys
from datetime import datetime
from telethon import TelegramClient, events
from telethon.errors import SessionPasswordNeededError, FloodWaitError
from telethon.tl.types import User, Chat, Channel
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# ============= CONFIGURATION =============
try:
    API_ID = int(os.getenv("API_ID", "29919905"))
    API_HASH = os.getenv("API_HASH", "717957f0e3ae20a7db004d08b66bfd30")
    SESSION_NAME = os.getenv("SESSION_NAME", "vzoel_session")
    OWNER_ID = int(os.getenv("OWNER_ID", "7847025168")) if os.getenv("OWNER_ID") else None
    COMMAND_PREFIX = os.getenv("COMMAND_PREFIX", ".")
    LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
    ENABLE_LOGGING = os.getenv("ENABLE_LOGGING", "true").lower() == "true"
except ValueError as e:
    print(f"‚ö†Ô∏è Configuration error: {e}")
    print("Please check your .env file")
    sys.exit(1)

# Validation
if not API_ID or not API_HASH:
    print("‚ùå ERROR: API_ID and API_HASH must be set in .env file!")
    print("Please create a .env file with your Telegram API credentials")
    sys.exit(1)

# Setup logging
if ENABLE_LOGGING:
    log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    logging.basicConfig(
        level=getattr(logging, LOG_LEVEL.upper(), logging.INFO),
        format=log_format,
        handlers=[
            logging.FileHandler('vzoel_enhanced.log'),
            logging.StreamHandler()
        ]
    )
else:
    logging.basicConfig(level=logging.WARNING)

logger = logging.getLogger(__name__)

# Initialize client
try:
    client = TelegramClient(SESSION_NAME, API_ID, API_HASH)
    logger.info("‚úÖ Telegram client initialized")
except Exception as e:
    logger.error(f"‚ùå Failed to initialize client: {e}")
    sys.exit(1)

# Global variables
start_time = None
spam_guard_enabled = False
spam_users = {}

# Logo URLs (Telegraph links)
LOGO_URL = "https://telegra.ph/file/8b9c2c5c5a5a5c5c5c5c5.jpg"  # Ganti dengan URL logo Anda
VZOEL_LOGO = "https://telegra.ph/file/vzoel-assistant-logo.jpg"  # Ganti dengan URL logo VZL

# ============= UTILITY FUNCTIONS =============

async def is_owner(user_id):
    """Check if user is owner"""
    try:
        if OWNER_ID:
            return user_id == OWNER_ID
        me = await client.get_me()
        return user_id == me.id
    except Exception as e:
        logger.error(f"Error checking owner: {e}")
        return False

async def animate_text(message, texts, delay=1.5):
    """Animate text by editing message multiple times"""
    for i, text in enumerate(texts):
        try:
            await message.edit(text)
            if i < len(texts) - 1:  # Don't sleep on last iteration
                await asyncio.sleep(delay)
        except Exception as e:
            logger.error(f"Animation error: {e}")
            break

async def get_broadcast_channels():
    """Get all channels and groups for broadcasting (improved)"""
    channels = []
    try:
        async for dialog in client.iter_dialogs():
            entity = dialog.entity
            
            # Skip private chats
            if isinstance(entity, User):
                continue
                
            # Include groups and channels where we can send messages
            if isinstance(entity, (Chat, Channel)):
                # For channels, check if we have broadcast rights or it's a group
                if isinstance(entity, Channel):
                    if entity.broadcast and not (entity.creator or entity.admin_rights):
                        continue  # Skip channels where we can't post
                
                channels.append({
                    'entity': entity,
                    'id': entity.id,
                    'title': getattr(entity, 'title', 'Unknown'),
                    'type': 'Channel' if isinstance(entity, Channel) and entity.broadcast else 'Group'
                })
                
    except Exception as e:
        logger.error(f"Error getting broadcast channels: {e}")
    
    return channels

async def log_command(event, command):
    """Log command usage"""
    try:
        user = await client.get_entity(event.sender_id)
        chat = await event.get_chat()
        chat_title = getattr(chat, 'title', 'Private Chat')
        user_name = getattr(user, 'first_name', 'Unknown') or 'Unknown'
        logger.info(f"Command '{command}' used by {user_name} ({user.id}) in {chat_title}")
    except Exception as e:
        logger.error(f"Error logging command: {e}")

async def get_user_info(event, user_input=None):
    """Get user information from reply or username/id"""
    user = None
    
    try:
        if event.is_reply and not user_input:
            # Get from reply
            reply_msg = await event.get_reply_message()
            user = await client.get_entity(reply_msg.sender_id)
        elif user_input:
            # Get from username or ID
            if user_input.isdigit():
                user = await client.get_entity(int(user_input))
            else:
                # Remove @ if present
                username = user_input.lstrip('@')
                user = await client.get_entity(username)
        else:
            return None
            
        return user
    except Exception as e:
        logger.error(f"Error getting user info: {e}")
        return None

# ============= PLUGIN 1: ALIVE COMMAND (WITH LOGO) =============

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}alive'))
async def alive_handler(event):
    """Enhanced alive command with animation and logo"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "alive")
    
    try:
        me = await client.get_me()
        uptime = datetime.now() - start_time if start_time else "Unknown"
        uptime_str = str(uptime).split('.')[0] if uptime != "Unknown" else "Unknown"
        
        alive_animations = [
            "üî• **Checking system status...**",
            "‚ö° **Loading components...**",
            "üöÄ **Initializing Vzoel Assistant...**",
            f"""
[üö©]({LOGO_URL}) **VZOEL ASSISTANT IS ALIVE!**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   üö© **ùó©ùó≠ùó¢ùóòùóü ùóîùó¶ùó¶ùóúùó¶ùóßùóîùó°ùóß** üö©
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ **Name:** {me.first_name or 'Vzoel Assistant'}
üÜî **ID:** `{me.id}`
üì± **Username:** @{me.username or 'None'}
‚ö° **Prefix:** `{COMMAND_PREFIX}`
‚è∞ **Uptime:** `{uptime_str}`
üî• **Status:** Active & Running
üì¶ **Version:** v2.1 Enhanced

‚ö° **Hak milik Vzoel Fox's ¬©2025 ~ LTPN** ‚ö°
            """.strip()
        ]
        
        msg = await event.reply(alive_animations[0])
        await animate_text(msg, alive_animations, delay=2)
        
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"Alive command error: {e}")

# ============= PLUGIN 2: ENHANCED GCAST COMMAND =============

@client.on(events.NewMessage(pattern=re.compile(rf'{re.escape(COMMAND_PREFIX)}gcast\s+(.+)', re.DOTALL)))
async def gcast_handler(event):
    """Enhanced Global Broadcast with improved error handling"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "gcast")
    
    message_to_send = event.pattern_match.group(1).strip()
    if not message_to_send:
        await event.reply("‚ùå **Usage:** `.gcast <message>`")
        return
    
    try:
        # 8-phase animation
        gcast_animations = [
            "üîç **Scanning available channels...**",
            "üì° **Establishing broadcast connection...**",
            "‚ö° **Initializing transmission protocol...**",
            "üöÄ **Preparing message distribution...**",
            "üî® **Starting global broadcast...**",
            "üîÑ **Broadcasting in progress...**",
            "‚úÖ **Broadcast transmission active...**",
            "üìä **Finalizing delivery status...**"
        ]
        
        msg = await event.reply(gcast_animations[0])
        
        # Animate first 4 phases
        for i in range(1, 5):
            await asyncio.sleep(1.5)
            await msg.edit(gcast_animations[i])
        
        # Get channels
        channels = await get_broadcast_channels()
        total_channels = len(channels)
        
        if total_channels == 0:
            await msg.edit("‚ùå **No available channels found for broadcasting!**")
            return
        
        # Continue animation
        await asyncio.sleep(1.5)
        await msg.edit(f"{gcast_animations[5]}\nüìä **Found:** `{total_channels}` chats")
        
        await asyncio.sleep(1.5)
        await msg.edit(f"{gcast_animations[6]}\nüìä **Broadcasting to:** `{total_channels}` chats")
        
        # Start broadcasting
        success_count = 0
        failed_count = 0
        failed_chats = []
        
        for i, channel_info in enumerate(channels, 1):
            try:
                entity = channel_info['entity']
                
                # Send message
                await client.send_message(entity, message_to_send)
                success_count += 1
                
                # Update progress every 3 messages or on last message
                if i % 3 == 0 or i == total_channels:
                    progress = (i / total_channels) * 100
                    current_title = channel_info['title'][:20]
                    
                    await msg.edit(f"""
üöÄ **Global Broadcast in Progress...**

üìä **Progress:** `{i}/{total_channels}` ({progress:.1f}%)
‚úÖ **Success:** `{success_count}`
‚ùå **Failed:** `{failed_count}`
‚ö° **Current:** {current_title}...
                    """.strip())
                
                # Rate limiting - important!
                await asyncio.sleep(0.5)
                
            except FloodWaitError as e:
                # Handle flood wait
                wait_time = e.seconds
                if wait_time > 300:  # Skip if wait is too long
                    failed_count += 1
                    failed_chats.append(f"{channel_info['title']} (Flood: {wait_time}s)")
                    continue
                    
                await asyncio.sleep(wait_time)
                try:
                    await client.send_message(entity, message_to_send)
                    success_count += 1
                except Exception:
                    failed_count += 1
                    failed_chats.append(f"{channel_info['title']} (Flood retry failed)")
                    
            except Exception as e:
                failed_count += 1
                error_msg = str(e)[:50]
                failed_chats.append(f"{channel_info['title']} ({error_msg})")
                logger.error(f"Gcast error for {channel_info['title']}: {e}")
                continue
        
        # Final animation phase
        await asyncio.sleep(2)
        await msg.edit(gcast_animations[7])
        
        await asyncio.sleep(2)
        
        # Calculate success rate
        success_rate = (success_count / total_channels * 100) if total_channels > 0 else 0
        
        final_message = f"""
‚úÖ **GLOBAL BROADCAST COMPLETED!**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    üì° **ùóïùó•ùó¢ùóîùóóùóñùóîùó¶ùóß ùó•ùóòùó£ùó¢ùó•ùóß** üì°
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä **Total Chats:** `{total_channels}`
‚úÖ **Successful:** `{success_count}`
‚ùå **Failed:** `{failed_count}`
üìà **Success Rate:** `{success_rate:.1f}%`

üî• **Message delivered successfully!**
‚ö° **Powered by Vzoel Assistant**
        """.strip()
        
        await msg.edit(final_message)
        
        # Send error log if there are failures
        if failed_chats and len(failed_chats) <= 10:  # Only show first 10 errors
            error_log = "**Failed Chats:**\n"
            for chat in failed_chats[:10]:
                error_log += f"‚Ä¢ {chat}\n"
            if len(failed_chats) > 10:
                error_log += f"‚Ä¢ And {len(failed_chats) - 10} more..."
                
            await event.reply(error_log)
        
    except Exception as e:
        await event.reply(f"‚ùå **Gcast Error:** {str(e)}")
        logger.error(f"Gcast command error: {e}")

# ============= PLUGIN 3: JOIN/LEAVE VC =============

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}joinvc'))
async def joinvc_handler(event):
    """Join Voice Chat with animation"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "joinvc")
    
    try:
        chat = await event.get_chat()
        if not hasattr(chat, 'id'):
            await event.reply("‚ùå **Cannot join VC in this chat!**")
            return
        
        animations = [
            "üî• **Connecting to voice chat...**",
            "üéµ **Initializing audio stream...**",
            "üöÄ **Joining voice chat...**",
            f"""
‚úÖ **VOICE CHAT JOINED!**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   üéµ **ùó©ùó¢ùóúùóñùóò ùóñùóõùóîùóß ùóîùóñùóßùóúùó©ùóò** üéµ
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìç **Chat:** {chat.title[:30] if hasattr(chat, 'title') else 'Private'}
üéôÔ∏è **Status:** Connected
üìä **Audio:** Ready
‚ö° **Quality:** HD

‚ö†Ô∏è **Note:** Full VC features require pytgcalls
üî• **Vzoel Assistant VC Ready!**
            """.strip()
        ]
        
        msg = await event.reply(animations[0])
        await animate_text(msg, animations, delay=1.5)
            
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"JoinVC error: {e}")

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}leavevc'))
async def leavevc_handler(event):
    """Leave Voice Chat with animation"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "leavevc")
    
    try:
        animations = [
            "üî• **Disconnecting from voice chat...**",
            "üéµ **Stopping audio stream...**",
            "üëã **Leaving voice chat...**",
            """
‚úÖ **VOICE CHAT LEFT!**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   üëã **ùó©ùó¢ùóúùóñùóò ùóñùóõùóîùóß ùóóùóúùó¶ùóñùó¢ùó°ùó°ùóòùóñùóßùóòùóó** üëã
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üîå **Status:** Disconnected
üéôÔ∏è **Audio:** Stopped
‚úÖ **Action:** Completed

üî• **Successfully left voice chat!**
‚ö° **Vzoel Assistant ready for next command**
            """.strip()
        ]
        
        msg = await event.reply(animations[0])
        await animate_text(msg, animations, delay=1.5)
            
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"LeaveVC error: {e}")

# ============= PLUGIN 4: VZL COMMAND (12 ANIMATIONS) =============

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}vzl'))
async def vzl_handler(event):
    """Vzoel command with 12-phase animation as requested"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "vzl")
    
    try:
        # 12 animation phases as requested
        vzl_animations = [
            "üî• **V**",
            "üî• **VZ**",
            "üî• **VZO**", 
            "üî• **VZOE**",
            "üî• **VZOEL**",
            "üöÄ **VZOEL F**",
            "üöÄ **VZOEL FO**",
            "üöÄ **VZOEL FOX**",
            "‚ö° **VZOEL FOX'S**",
            "‚ú® **VZOEL FOX'S A**",
            "üåü **VZOEL FOX'S ASS**",
            f"""
[üî•]({VZOEL_LOGO}) **VZOEL FOX'S ASSISTANT** üî•

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   üö© **ùó©ùó≠ùó¢ùóòùóü ùóîùó¶ùó¶ùóúùó¶ùóßùóîùó°ùóß** üö©
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚ö° **The most advanced Telegram userbot**
üöÄ **Built with passion and precision**
üî• **Powered by Telethon & Python**
‚ú® **Created by Vzoel Fox's (LTPN)**

üì± **Features:**
‚Ä¢ Global Broadcasting
‚Ä¢ Voice Chat Control  
‚Ä¢ Advanced Animations
‚Ä¢ Multi-Plugin System
‚Ä¢ Real-time Monitoring
‚Ä¢ Spam Protection
‚Ä¢ User ID Lookup

‚ö° **Hak milik Vzoel Fox's ¬©2025 ~ LTPN** ‚ö°
            """.strip()
        ]
        
        msg = await event.reply(vzl_animations[0])
        await animate_text(msg, vzl_animations, delay=1.2)
        
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"VZL command error: {e}")

# ============= PLUGIN 5: ID COMMAND (NEW) =============

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}id(\s+(.+))?'))
async def id_handler(event):
    """Get user ID from reply or username"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "id")
    
    try:
        user_input = event.pattern_match.group(2)
        user = await get_user_info(event, user_input)
        
        if not user:
            if event.is_reply:
                await event.reply("‚ùå **Could not get user from reply!**")
            else:
                await event.reply(f"‚ùå **Usage:** `{COMMAND_PREFIX}id` (reply to message) or `{COMMAND_PREFIX}id username/id`")
            return
        
        # Get additional info
        is_bot = getattr(user, 'bot', False)
        is_verified = getattr(user, 'verified', False)
        is_scam = getattr(user, 'scam', False)
        is_fake = getattr(user, 'fake', False)
        is_premium = getattr(user, 'premium', False)
        
        # Format status
        status_icons = []
        if is_bot:
            status_icons.append("ü§ñ Bot")
        if is_verified:
            status_icons.append("‚úÖ Verified")
        if is_premium:
            status_icons.append("‚≠ê Premium")
        if is_scam:
            status_icons.append("‚ö†Ô∏è Scam")
        if is_fake:
            status_icons.append("üö´ Fake")
        
        status_text = " | ".join(status_icons) if status_icons else "üë§ Regular User"
        
        id_info = f"""
üÜî **USER ID INFORMATION**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   üîç **ùó®ùó¶ùóòùó• ùóúùóó ùóüùó¢ùó¢ùóûùó®ùó£** üîç
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ **Name:** {user.first_name or 'None'} {user.last_name or ''}
üÜî **User ID:** `{user.id}`
üì± **Username:** @{user.username or 'None'}
üìû **Phone:** `{user.phone or 'Hidden'}`
üè∑Ô∏è **Status:** {status_text}
üåê **Language:** `{user.lang_code or 'Unknown'}`

üìä **Account Info:**
‚Ä¢ **First Name:** `{user.first_name or 'Not set'}`
‚Ä¢ **Last Name:** `{user.last_name or 'Not set'}`
‚Ä¢ **Bio Available:** {'Yes' if hasattr(user, 'about') else 'No'}

‚ö° **Vzoel Assistant ID Lookup**
        """.strip()
        
        await event.reply(id_info)
        
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"ID command error: {e}")

# ============= PLUGIN 6: INFO COMMAND =============

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}info'))
async def info_handler(event):
    """System information command"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "info")
    
    try:
        me = await client.get_me()
        uptime = datetime.now() - start_time if start_time else "Unknown"
        uptime_str = str(uptime).split('.')[0] if uptime != "Unknown" else "Unknown"
        
        info_text = f"""
ü§ñ **VZOEL ASSISTANT INFO**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   üìä **ùó¶ùó¨ùó¶ùóßùóòùó† ùóúùó°ùóôùó¢ùó•ùó†ùóîùóßùóúùó¢ùó°** üìä
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ **Name:** {me.first_name or 'Vzoel Assistant'}
üÜî **User ID:** `{me.id}`
üì± **Username:** @{me.username or 'None'}
üìû **Phone:** `{me.phone or 'Hidden'}`
‚ö° **Prefix:** `{COMMAND_PREFIX}`
‚è∞ **Uptime:** `{uptime_str}`
üöÄ **Version:** v2.1 Enhanced Edition
üîß **Framework:** Telethon
üêç **Language:** Python 3.9+
üíæ **Session:** Active
üåç **Server:** Cloud Hosted
üõ°Ô∏è **Spam Guard:** {'Enabled' if spam_guard_enabled else 'Disabled'}

üìä **Available Commands:**
‚Ä¢ `{COMMAND_PREFIX}alive` - System status
‚Ä¢ `{COMMAND_PREFIX}gcast` - Global broadcast
‚Ä¢ `{COMMAND_PREFIX}joinvc` - Join voice chat
‚Ä¢ `{COMMAND_PREFIX}leavevc` - Leave voice chat
‚Ä¢ `{COMMAND_PREFIX}vzl` - Vzoel animation
‚Ä¢ `{COMMAND_PREFIX}id` - Get user ID
‚Ä¢ `{COMMAND_PREFIX}help` - Show all commands
‚Ä¢ `{COMMAND_PREFIX}sg` - Spam guard toggle
‚Ä¢ `{COMMAND_PREFIX}infofounder` - Founder info
‚Ä¢ `{COMMAND_PREFIX}ping` - Response time

‚ö° **Hak milik Vzoel Fox's ¬©2025 ~ LTPN** ‚ö°
        """.strip()
        
        await event.edit(info_text)
        
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"Info command error: {e}")

# ============= PLUGIN 7: HELP COMMAND (WITH LOGO) =============

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}help'))
async def help_handler(event):
    """Help command with all available commands and logo"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "help")
    
    try:
        help_text = f"""
[üÜò]({LOGO_URL}) **VZOEL ASSISTANT HELP**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   üìö **ùóñùó¢ùó†ùó†ùóîùó°ùóó ùóüùóúùó¶ùóß** üìö
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üî• **MAIN COMMANDS:**
‚Ä¢ `{COMMAND_PREFIX}alive` - Check bot status
‚Ä¢ `{COMMAND_PREFIX}info` - System information
‚Ä¢ `{COMMAND_PREFIX}vzl` - Vzoel animation (12 phases)
‚Ä¢ `{COMMAND_PREFIX}help` - Show this help
‚Ä¢ `{COMMAND_PREFIX}ping` - Response time test

üì° **BROADCAST:**
‚Ä¢ `{COMMAND_PREFIX}gcast <message>` - Enhanced global broadcast

üéµ **VOICE CHAT:**
‚Ä¢ `{COMMAND_PREFIX}joinvc` - Join voice chat
‚Ä¢ `{COMMAND_PREFIX}leavevc` - Leave voice chat

üõ°Ô∏è **SECURITY:**
‚Ä¢ `{COMMAND_PREFIX}sg` - Spam guard toggle

üîç **UTILITIES:**
‚Ä¢ `{COMMAND_PREFIX}id` - Get user ID (reply/username)
‚Ä¢ `{COMMAND_PREFIX}infofounder` - Founder information

üìù **USAGE EXAMPLES:**
```
{COMMAND_PREFIX}alive
{COMMAND_PREFIX}gcast Hello everyone!
{COMMAND_PREFIX}id @username
{COMMAND_PREFIX}id (reply to message)
{COMMAND_PREFIX}joinvc
{COMMAND_PREFIX}vzl
{COMMAND_PREFIX}sg
```

‚ö†Ô∏è **NOTE:** All commands are owner-only for security

‚ö° **Support:** @VZLfx | @VZLfxs
üî• **Created by Vzoel Fox's (LTPN)**
üì± **Instagram:** vzoel.fox_s
‚ö° **Hak milik Vzoel Fox's ¬©2025 ~ LTPN** ‚ö°
        """.strip()
        
        await event.edit(help_text)
        
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"Help command error: {e}")

# ============= PLUGIN 8: SPAM GUARD =============

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}sg'))
async def spam_guard_handler(event):
    """Toggle spam guard with status display"""
    if not await is_owner(event.sender_id):
        return
    
    global spam_guard_enabled
    await log_command(event, "sg")
    
    try:
        spam_guard_enabled = not spam_guard_enabled
        status = "**ENABLED** ‚úÖ" if spam_guard_enabled else "**DISABLED** ‚ùå"
        
        sg_text = f"""
üõ°Ô∏è **SPAM GUARD STATUS**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   üõ°Ô∏è **ùó¶ùó£ùóîùó† ùó£ùó•ùó¢ùóßùóòùóñùóßùóúùó¢ùó°** üõ°Ô∏è
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üî• **Status:** {status}
‚ö° **Mode:** Auto-detection
üéØ **Action:** Delete & Warn
üìä **Threshold:** 5 messages/10s
‚è∞ **Detection Window:** 10 seconds
üö´ **Protected Users:** Owner only

{'üü¢ **Protection is now ACTIVE!**' if spam_guard_enabled else 'üî¥ **Protection is now INACTIVE!**'}

üí° **How it works:**
- Monitors message frequency
- Auto-deletes spam messages
- Shows warning to spammers
- Protects all your chats

‚ö° **Hak milik Vzoel Fox's ¬©2025 ~ LTPN** ‚ö°
        """.strip()
        
        await event.edit(sg_text)
        
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"Spam guard error: {e}")

@client.on(events.NewMessage)
async def spam_detection(event):
    """Auto spam detection and prevention"""
    global spam_guard_enabled, spam_users
    
    if not spam_guard_enabled or await is_owner(event.sender_id):
        return
    
    try:
        user_id = event.sender_id
        current_time = time.time()
        
        if user_id not in spam_users:
            spam_users[user_id] = []
        
        # Remove old messages (older than 10 seconds)
        spam_users[user_id] = [msg_time for msg_time in spam_users[user_id] if current_time - msg_time < 10]
        
        # Add current message
        spam_users[user_id].append(current_time)
        
        # Check if spam (more than 5 messages in 10 seconds)
        if len(spam_users[user_id]) > 5:
            try:
                await event.delete()
                user = await client.get_entity(user_id)
                user_name = getattr(user, 'first_name', 'Unknown')
                
                warning_msg = await event.respond(
                    f"üõ°Ô∏è **SPAM DETECTED!**\n"
                    f"üë§ **User:** {user_name}\n"
                    f"‚ö†Ô∏è **Action:** Message deleted\n"
                    f"üìä **Messages:** {len(spam_users[user_id])} in 10s\n"
                    f"üî• **Vzoel Protection Active**"
                )
                
                await asyncio.sleep(5)
                await warning_msg.delete()
                
                # Reset counter
                spam_users[user_id] = []
                
                logger.info(f"Spam detected and handled for user {user_name} ({user_id})")
                
            except Exception as e:
                logger.error(f"Spam action error: {e}")
    
    except Exception as e:
        logger.error(f"Spam detection error: {e}")

# ============= PLUGIN 9: INFO FOUNDER (WITH LOGO) =============

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}infofounder'))
async def infofounder_handler(event):
    """Founder information with logo - exact as requested"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "infofounder")
    
    try:
        founder_info = f"""
[‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó]({VZOEL_LOGO})
   üö© **ùó©ùó≠ùó¢ùóòùóü ùóîùó¶ùó¶ùóúùó¶ùóßùóîùó°ùóß** üö©
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚ü¢ Founder    : **ùó©ùòáùóºùó≤ùóπ ùóôùóºùòÖ'ùòÄ (Ltpn)**
‚ü¢ Instagram  : vzoel.fox_s
‚ü¢ Telegram   : @VZLfx | @VZLfxs
‚ü¢ Channel    : t.me/nama_channel

‚ö° Hak milik **ùó©ùòáùóºùó≤ùóπ ùóôùóºùòÖ'ùòÄ** ¬©2025 ~ LTPN. ‚ö°
        """.strip()
        
        await event.edit(founder_info)
        
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"InfoFounder error: {e}")

# ============= PLUGIN 10: PING COMMAND =============

@client.on(events.NewMessage(pattern=rf'{re.escape(COMMAND_PREFIX)}ping'))
async def ping_handler(event):
    """Ping command with response time"""
    if not await is_owner(event.sender_id):
        return
    
    await log_command(event, "ping")
    
    try:
        start = time.time()
        msg = await event.reply("üèì **Pinging...**")
        end = time.time()
        
        ping_time = (end - start) * 1000
        
        ping_text = f"""
üèì **PONG!**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   ‚ö° **ùó£ùóúùó°ùóö ùó•ùóòùó¶ùó®ùóüùóß** ‚ö°
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚ö° **Response Time:** `{ping_time:.2f}ms`
üöÄ **Status:** Active
üî• **Server:** Online
‚úÖ **Connection:** Stable
üì° **Latency:** {'Low' if ping_time < 100 else 'Normal' if ping_time < 300 else 'High'}

‚ö° **Vzoel Assistant is running smoothly!**
        """.strip()
        
        await msg.edit(ping_text)
        
    except Exception as e:
        await event.reply(f"‚ùå **Error:** {str(e)}")
        logger.error(f"Ping error: {e}")

# ============= STARTUP AND MAIN FUNCTIONS =============

async def send_startup_message():
    """Send startup notification to saved messages"""
    try:
        me = await client.get_me()
        
        startup_msg = f"""
[üöÄ]({LOGO_URL}) **VZOEL ASSISTANT STARTED!**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   üî• **ùó¶ùó¨ùó¶ùóßùóòùó† ùóîùóñùóßùóúùó©ùóîùóßùóòùóó** üî•
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚úÖ **All systems operational**
üë§ **User:** {me.first_name}
üÜî **ID:** `{me.id}`
‚ö° **Prefix:** `{COMMAND_PREFIX}`
‚è∞ **Started:** `{start_time.strftime("%Y-%m-%d %H:%M:%S")}`

üìå **Loaded Plugins (Enhanced Edition):**
‚Ä¢ ‚úÖ Alive System (3 animations + logo)
‚Ä¢ ‚úÖ Enhanced Global Broadcast (8 animations)
‚Ä¢ ‚úÖ Voice Chat Control
‚Ä¢ ‚úÖ Vzoel Animation (12 phases + logo)
‚Ä¢ ‚úÖ User ID Lookup System
‚Ä¢ ‚úÖ Information System
‚Ä¢ ‚úÖ Help Command (with logo)
‚Ä¢ ‚úÖ Spam Guard (Auto-detection)
‚Ä¢ ‚úÖ Founder Info (with logo)
‚Ä¢ ‚úÖ Ping System

üí° **Quick Start:**
‚Ä¢ `{COMMAND_PREFIX}help` - Show all commands
‚Ä¢ `{COMMAND_PREFIX}alive` - Check status
‚Ä¢ `{COMMAND_PREFIX}vzl` - 12-phase animation
‚Ä¢ `{COMMAND_PREFIX}gcast <message>` - Enhanced broadcast
‚Ä¢ `{COMMAND_PREFIX}id @username` - Get user ID
‚Ä¢ `{COMMAND_PREFIX}sg` - Toggle spam protection

üî• **Enhanced features:**
‚Ä¢ Improved gcast with better error handling
‚Ä¢ New ID lookup plugin
‚Ä¢ Logo integration on key commands
‚Ä¢ Better broadcast channel detection
‚Ä¢ Flood wait protection

‚ö° **Powered by Vzoel Fox's (LTPN)**
        """.strip()
        
        await client.send_message('me', startup_msg)
        logger.info("‚úÖ Enhanced startup message sent successfully")
        
    except Exception as e:
        logger.error(f"Failed to send startup message: {e}")

async def startup():
    """Enhanced startup function"""
    global start_time
    start_time = datetime.now()
    
    logger.info("üöÄ Starting Vzoel Assistant (Enhanced Edition)...")
    
    try:
        await client.start()
        me = await client.get_me()
        
        logger.info(f"‚úÖ Vzoel Assistant started successfully!")
        logger.info(f"üë§ Logged in as: {me.first_name} (@{me.username or 'No username'})")
        logger.info(f"üÜî User ID: {me.id}")
        logger.info(f"üìå All plugins integrated in main.py")
        logger.info(f"‚ö° Enhanced commands: alive, gcast, joinvc, leavevc, vzl, id, info, help, sg, infofounder, ping")
        logger.info(f"üî• New features: Enhanced gcast, ID lookup, Logo integration")
        
        # Send startup message
        await send_startup_message()
            
    except SessionPasswordNeededError:
        logger.error("‚ùå Two-factor authentication enabled. Please login manually first.")
        return False
    except Exception as e:
        logger.error(f"‚ùå Error starting Vzoel Assistant: {e}")
        return False
    
    return True

async def main():
    """Main function to run the enhanced userbot"""
    logger.info("üî• Initializing Vzoel Assistant Enhanced Edition...")
    
    # Validate configuration
    logger.info("üîç Validating configuration...")
    logger.info(f"üì± API ID: {API_ID}")
    logger.info(f"üìù Session: {SESSION_NAME}")
    logger.info(f"‚ö° Prefix: {COMMAND_PREFIX}")
    logger.info(f"üÜî Owner ID: {OWNER_ID or 'Auto-detect'}")
    logger.info(f"üìÇ Mode: Enhanced Edition (All-in-One with improvements)")
    
    # Start Vzoel Assistant
    if await startup():
        logger.info("üî• Vzoel Assistant is now running (Enhanced Edition)...")
        logger.info("üìù Press Ctrl+C to stop")
        logger.info("üéØ Enhanced features: Better gcast, ID lookup, Logo integration")
        
        try:
            await client.run_until_disconnected()
        except KeyboardInterrupt:
            logger.info("üëã Vzoel Assistant stopped by user")
        except Exception as e:
            logger.error(f"‚ùå Unexpected error: {e}")
        finally:
            logger.info("üî• Disconnecting...")
            try:
                await client.disconnect()
            except Exception as e:
                logger.error(f"Error during disconnect: {e}")
            logger.info("‚úÖ Vzoel Assistant stopped successfully!")
    else:
        logger.error("‚ùå Failed to start Vzoel Assistant!")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except Exception as e:
        logger.error(f"‚ùå Fatal error: {e}")
        sys.exit(1)

# ============= END OF VZOEL ASSISTANT ENHANCED EDITION =============

"""
üî• VZOEL ASSISTANT - ENHANCED EDITION üî•

‚úÖ NEW FEATURES ADDED:
1. Enhanced gcast.py - Improved error handling, flood protection, better channel detection
2. NEW id.py - User ID lookup by reply or username/ID
3. Logo integration - Telegraph links on alive, help, infofounder, vzl commands
4. Better broadcast system - Based on ultroid's broadcast.py reference
5. Improved error reporting for gcast failures
6. Enhanced channel filtering for better broadcast success
7. FloodWaitError handling with smart retry logic
8. Better progress reporting during broadcast

üöÄ ENHANCED GCAST FEATURES:
‚Ä¢ Smart channel detection (groups + channels with permissions)
‚Ä¢ FloodWait error handling with retry logic
‚Ä¢ Better progress reporting every 3 messages
‚Ä¢ Error logging with failed chat details
‚Ä¢ Improved success rate calculation
‚Ä¢ Rate limiting to prevent flood errors

üîç NEW ID COMMAND FEATURES:
‚Ä¢ Get user ID by replying to their message
‚Ä¢ Get user ID by username or user ID
‚Ä¢ Shows comprehensive user information
‚Ä¢ Detects bots, verified, premium, scam accounts
‚Ä¢ Shows phone number if available

üñºÔ∏è LOGO INTEGRATION:
‚Ä¢ Telegraph logo links on key commands
‚Ä¢ Enhanced visual presentation
‚Ä¢ Consistent branding across commands

üõ†Ô∏è SETUP INSTRUCTIONS:
1. Save this as main.py
2. Update LOGO_URL and VZOEL_LOGO with your telegraph links
3. Create .env file with your credentials
4. Install: pip install telethon python-dotenv
5. Run: python main.py

‚ö° All improvements maintain existing architecture!
‚ö° Created by Vzoel Fox's (LTPN) ‚ö°
"""